     1: import React, { useEffect, useMemo, useRef, useState } from "react";
     2: import axiosInstance from "../config/axios.config.js";
     3: 
     4: const BUCKETS = ["Chicken", "Salad", "Pasta", "Roll"];
     5: 
     6: const KEYWORDS = {
     7:   Chicken: ["chicken","charcoal","roast","wings","drumstick","breast","thigh","tandoori","peri","bbq"],
     8:   Salad: ["salad","coleslaw","slaw","greek","potato","pumpkin","asian","garden","caesar","vinaigrette"],
     9:   Pasta: ["pasta","spaghetti","penne","fettuccine","alfredo","bolognese","lasagna","lasagne","mac","gnocchi"],
    10:   Roll: ["roll","bread roll","wrap","shawarma","kebab","sub","tortilla","burrito"],
    11: };
    12: 
    13: const CATEGORY_HINTS = {
    14:   chicken: "Chicken", poultry: "Chicken",
    15:   salad: "Salad", sides: "Salad",
    16:   pasta: "Pasta", italian: "Pasta",
    17:   roll: "Roll", rolls: "Roll", breads: "Roll", bakery: "Roll",
    18: };
    19: 
    20: function scoreItemForBucket(item, bucket) {
    21:   const name = String(item.name || "").toLowerCase();
    22:   const cat  = String(item.category || "").toLowerCase();
    23:   const img  = String(item.image || item.img || "").toLowerCase();
    24:   const keys = KEYWORDS[bucket];
    25: 
    26:   let score = 0;
    27:   keys.forEach((k) => { if (name.includes(k)) score += 5; });
    28:   if (CATEGORY_HINTS[cat] === bucket) score += 6;
    29:   keys.forEach((k) => { if (img.includes(k)) score += 2; });
    30:   if (cat.includes(bucket.toLowerCase())) score += 3;
    31: 
    32:   return score;
    33: }
    34: 
    35: function pickMatches(items = [], minScore = 1) {
    36:   // returns [{ bucket, item, score }]
    37:   const ranked = BUCKETS.map((b) => {
    38:     const candidates = items
    39:       .map((it, idx) => ({ it, idx, score: scoreItemForBucket(it, b) }))
    40:       .filter(({ score }) => score >= minScore)
    41:       .sort((a, b2) => b2.score - a.score);
    42:     return { bucket: b, candidates };
    43:   });
    44: 
    45:   const usedIdx = new Set();
    46:   const chosen = [];
    47:   for (const { bucket, candidates } of ranked) {
    48:     const pick = candidates.find((c) => !usedIdx.has(c.idx));
    49:     if (pick) {
    50:       usedIdx.add(pick.idx);
    51:       chosen.push({ bucket, item: pick.it, score: pick.score });
    52:     }
    53:   }
    54:   return chosen;
    55: }
    56: 
    57: export default function MenuCarousel({
    58:   fetchUrl,
    59:   autoplay = true,
    60:   interval = 4000,
    61: }) {
    62:   const [index, setIndex] = useState(0);
    63:   const [slides, setSlides] = useState([]); // will be EXACTLY 4 when we have data
    64:   const [loading, setLoading] = useState(true);
    65: 
    66:   const API_URL = (import.meta.env.VITE_API_URL || "").replace(/\/$/, "");
    67:   const SERVER_URL = API_URL.replace(/\/api$/, "");
    68: 
    69:   const joinImageUrl = (path) => {
    70:     if (!path) return "";
    71:     if (/^https?:\/\//i.test(path)) return path;
    72:     // If SERVER_URL is empty, leave relative path as-is
    73:     if (!SERVER_URL) return path.startsWith("/") ? path : `/${path}`;
    74:     return `${SERVER_URL}${path.startsWith("/") ? "" : "/"}${path}`;
    75:   };
    76: 
    77:   // Utility: chunk array into pages of given size
    78:   const chunk = (arr, size) => {
    79:     const res = [];
    80:     for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
    81:     return res;
    82:   };
    83: 
    84:   // Build a list of cards from data (many items), prioritized by bucket matches
    85:   const buildCards = (data) => {
    86:     if (!Array.isArray(data) || data.length === 0) return [];
    87: 
    88:     // prefer items that have an image we can render
    89:     const withImg = data.filter((d) => !!(d?.image || d?.img));
    90: 
    91:     const topMatches = pickMatches(withImg, 1);
    92:     const used = new Set(topMatches.map(({ item }) => item)); // same references, ok
    93:     const remaining = withImg.filter((it) => !used.has(it));
    94:     const secondMatches = pickMatches(remaining, 1);
    95: 
    96:     const toCard = (bucket, item) => ({
    97:       title: bucket,
    98:       subtitle: item?.name || "",
    99:       src: joinImageUrl(item?.image || item?.img || ""),
   100:       alt: item?.name || bucket,
   101:     });
   102: 
   103:     // Start with one per bucket (max 4)
   104:     const firstWave = topMatches.map(({ bucket, item }) => toCard(bucket, item));
   105: 
   106:     // Fill any gaps (still keeping bucket titles consistent)
   107:     const secondWave = secondMatches.map(({ bucket, item }) => toCard(bucket, item));
   108: 
   109:     // If still short, fallback to any remaining items with generic titles
   110:     const fallback = remaining
   111:       .filter((it) => !!(it?.image || it?.img))
   112:       .map((it) => ({
   113:         title: it?.category || "Featured",
   114:         subtitle: it?.name || "",
   115:         src: joinImageUrl(it?.image || it?.img || ""),
   116:         alt: it?.name || it?.category || "Featured",
   117:       }));
   118: 
   119:     const combined = [...firstWave, ...secondWave, ...fallback].filter((c) => !!c.src);
   120:     return combined;
   121:   };
   122: 
   123:   useEffect(() => {
   124:     let mounted = true;
   125:     (async () => {
   126:       setLoading(true);
   127:       try {
   128:         const url = fetchUrl || `${API_URL}/menu-items`;
   129:         const res = await axiosInstance.get(url);
   130:         const raw = Array.isArray(res.data?.data)
   131:           ? res.data.data
   132:           : (Array.isArray(res.data) ? res.data : []);
   133:         const built = buildCards(raw);
   134: 
   135:         if (mounted) {
   136:           setSlides(built);
   137:           setIndex(0);
   138:         }
   139:       } catch (err) {
   140:         if (mounted) {
   141:           setSlides([]);
   142:           setIndex(0);
   143:         }
   144:       } finally {
   145:         mounted && setLoading(false);
   146:       }
   147:     })();
   148:     return () => { mounted = false; };
   149:   }, [fetchUrl, API_URL]);
   150: 
   151:   // Build pages with exactly 4 items per page
   152:   const pages = useMemo(() => {
   153:     if (slides.length === 0) return [];
   154:     return chunk(slides, 4);
   155:   }, [slides]);
   156: 
   157:   const pageCount = pages.length; // 0 or 2
   158:   const wrap = (n) => (n + Math.max(pageCount, 1)) % Math.max(pageCount, 1);
   159:   const go = (i) => setIndex(wrap(i));
   160:   const next = () => setIndex((i) => wrap(i + 1));
   161:   const prev = () => setIndex((i) => wrap(i - 1));
   162: 
   163:   // Autoplay (only if we truly have 2 pages)
   164:   useEffect(() => {
   165:     if (!autoplay || pageCount <= 1) return;
   166:     const id = setInterval(next, interval);
   167:     return () => clearInterval(id);
   168:   }, [autoplay, interval, pageCount]);
   169: 
   170:   // Keyboard arrows
   171:   const rootRef = useRef(null);
   172:   useEffect(() => {
   173:     const el = rootRef.current;
   174:     if (!el) return;
   175:     const onKey = (e) => {
   176:       if (e.key === "ArrowRight") next();
   177:       if (e.key === "ArrowLeft") prev();
   178:     };
   179:     el.addEventListener("keydown", onKey);
   180:     return () => el.removeEventListener("keydown", onKey);
   181:   }, []);
   182: 
   183:   // Touch swipe
   184:   const startX = useRef(0);
   185:   const deltaX = useRef(0);
   186:   const onTouchStart = (e) => {
   187:     startX.current = e.touches[0].clientX;
   188:     deltaX.current = 0;
   189:   };
   190:   const onTouchMove = (e) => {
   191:     deltaX.current = e.touches[0].clientX - startX.current;
   192:   };
   193:   const onTouchEnd = () => {
   194:     const THRESH = 40;
   195:     if (deltaX.current < -THRESH) next();
   196:     else if (deltaX.current > THRESH) prev();
   197:     startX.current = 0;
   198:     deltaX.current = 0;
   199:   };
   200: 
   201:   // Styles use pageCount (not item count)
   202:   const trackStyle = useMemo(
   203:     () => ({
   204:       display: "flex",
   205:       transition: "transform 400ms ease",
   206:       transform: `translateX(-${(pageCount ? index : 0) * 100}%)`,
   207:       width: `${Math.max(pageCount, 1) * 100}%`,
   208:     }),
   209:     [index, pageCount]
   210:   );
   211:   const slideStyle = {
   212:     width: `${100 / Math.max(pageCount || 1, 1)}%`,
   213:     flex: "0 0 auto",
   214:   };
   215: 
   216:   if (!loading && slides.length === 0) {
   217:     return (
   218:       <section className="menu-carousel empty" aria-label="Featured menu items" />
   219:     );
   220:   }
   221: 
   222:   return (
   223:     <section
   224:       className="menu-carousel"
   225:       ref={rootRef}
   226:       tabIndex={0}
   227:       role="region"
   228:       aria-roledescription="carousel"
   229:       aria-label="Featured menu items"
   230:       onTouchStart={onTouchStart}
   231:       onTouchMove={onTouchMove}
   232:       onTouchEnd={onTouchEnd}
   233:     >
   234:       {/* Prev */}
   235:       <button
   236:         type="button"
   237:         className="carousel-nav prev"
   238:         aria-label="Previous"
   239:         onClick={prev}
   240:         disabled={loading || pageCount <= 1}
   241:       >
   242:         <img src="/Vector.png" alt="Previous" />
   243:       </button>
   244: 
   245:       {/* Track (each page shows 4 items) */}
   246:       <div className="menu-items" style={{ overflow: "hidden" }}>
   247:         <div className="menu-track" style={trackStyle}>
   248:           {pages.map((group, pageIdx) => (
   249:             <div
   250:               className="menu-page"
   251:               style={slideStyle}
   252:               key={`page-${pageIdx}`}
   253:               aria-roledescription="slide"
   254:               aria-label={`Slide ${pageIdx + 1} of ${pageCount}`}
   255:             >
   256:               <div
   257:                 className="menu-page-inner"
   258:                 // 4 items per page; on small screens CSS may override to 2 cols
   259:                 style={{ display: "grid", gridTemplateColumns: "repeat(4, 1fr)", gap: 16 }}
   260:               >
   261:                 {group.map((it, i) => (
   262:                   <div className="menu-item" key={`${it.title}-${i}`}>
   263:                     <img src={it.src} alt={it.alt || it.title} />
   264:                     <h3>{it.title}</h3>
   265:                     {it.subtitle ? <p className="subtitle">{it.subtitle}</p> : null}
   266:                   </div>
   267:                 ))}
   268:               </div>
   269:             </div>
   270:           ))}
   271:         </div>
   272:       </div>
   273: 
   274:       {/* Next */}
   275:       <button
   276:         type="button"
   277:         className="carousel-nav next"
   278:         aria-label="Next"
   279:         onClick={next}
   280:         disabled={loading || pageCount <= 1}
   281:       >
   282:         <img src="/Vector-1.png" alt="Next" />
   283:       </button>
   284: 
   285:       {/* Dots */}
   286:       {pageCount > 1 && (
   287:         <div className="carousel-dots" aria-label="Select slide">
   288:           {Array.from({ length: pageCount }).map((_, i) => (
   289:             <span
   290:               key={i}
   291:               className={`dot ${i === index ? "active" : ""}`}
   292:               onClick={() => go(i)}
   293:               role="button"
   294:               tabIndex={0}
   295:               aria-label={`Go to slide ${i + 1}`}
   296:               onKeyDown={(e) => e.key === "Enter" && go(i)}
   297:             />
   298:           ))}
   299:         </div>
   300:       )}
   301:     </section>
   302:   );
   303: }
